{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.UpdateExpression = UpdateExpression;\nexports.ObjectExpression = ObjectExpression;\nexports.DoExpression = DoExpression;\nexports.Binary = Binary;\nexports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.TSAsExpression = TSAsExpression;\nexports.TSTypeAssertion = TSTypeAssertion;\nexports.TSIntersectionType = exports.TSUnionType = TSUnionType;\nexports.TSInferType = TSInferType;\nexports.BinaryExpression = BinaryExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.AwaitExpression = exports.YieldExpression = YieldExpression;\nexports.ClassExpression = ClassExpression;\nexports.UnaryLike = UnaryLike;\nexports.FunctionExpression = FunctionExpression;\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.OptionalMemberExpression = OptionalMemberExpression;\nexports.OptionalCallExpression = OptionalCallExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.LogicalExpression = LogicalExpression;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nconst PRECEDENCE = {\n  \"||\": 0,\n  \"??\": 0,\n  \"&&\": 1,\n  \"|\": 2,\n  \"^\": 3,\n  \"&\": 4,\n  \"==\": 5,\n  \"===\": 5,\n  \"!=\": 5,\n  \"!==\": 5,\n  \"<\": 6,\n  \">\": 6,\n  \"<=\": 6,\n  \">=\": 6,\n  in: 6,\n  instanceof: 6,\n  \">>\": 7,\n  \"<<\": 7,\n  \">>>\": 7,\n  \"+\": 8,\n  \"-\": 8,\n  \"*\": 9,\n  \"/\": 9,\n  \"%\": 9,\n  \"**\": 10\n};\n\nconst isClassExtendsClause = (node, parent) => (t.isClassDeclaration(parent) || t.isClassExpression(parent)) && parent.superClass === node;\n\nfunction NullableTypeAnnotation(node, parent) {\n  return t.isArrayTypeAnnotation(parent);\n}\n\nfunction FunctionTypeAnnotation(node, parent, printStack) {\n  return t.isUnionTypeAnnotation(parent) || t.isIntersectionTypeAnnotation(parent) || t.isArrayTypeAnnotation(parent) || t.isTypeAnnotation(parent) && t.isArrowFunctionExpression(printStack[printStack.length - 3]);\n}\n\nfunction UpdateExpression(node, parent) {\n  return t.isMemberExpression(parent, {\n    object: node\n  }) || t.isOptionalMemberExpression(parent, {\n    object: node\n  }) || t.isCallExpression(parent, {\n    callee: node\n  }) || t.isOptionalCallExpression(parent, {\n    callee: node\n  }) || t.isNewExpression(parent, {\n    callee: node\n  }) || isClassExtendsClause(node, parent);\n}\n\nfunction ObjectExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack, {\n    considerArrow: true\n  });\n}\n\nfunction DoExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack);\n}\n\nfunction Binary(node, parent) {\n  if (node.operator === \"**\" && t.isBinaryExpression(parent, {\n    operator: \"**\"\n  })) {\n    return parent.left === node;\n  }\n\n  if (isClassExtendsClause(node, parent)) {\n    return true;\n  }\n\n  if ((t.isCallExpression(parent) || t.isOptionalCallExpression(parent) || t.isNewExpression(parent)) && parent.callee === node || t.isUnaryLike(parent) || (t.isMemberExpression(parent) || t.isOptionalMemberExpression(parent)) && parent.object === node || t.isAwaitExpression(parent)) {\n    return true;\n  }\n\n  if (t.isBinary(parent)) {\n    const parentOp = parent.operator;\n    const parentPos = PRECEDENCE[parentOp];\n    const nodeOp = node.operator;\n    const nodePos = PRECEDENCE[nodeOp];\n\n    if (parentPos === nodePos && parent.right === node && !t.isLogicalExpression(parent) || parentPos > nodePos) {\n      return true;\n    }\n  }\n}\n\nfunction UnionTypeAnnotation(node, parent) {\n  return t.isArrayTypeAnnotation(parent) || t.isNullableTypeAnnotation(parent) || t.isIntersectionTypeAnnotation(parent) || t.isUnionTypeAnnotation(parent);\n}\n\nfunction TSAsExpression() {\n  return true;\n}\n\nfunction TSTypeAssertion() {\n  return true;\n}\n\nfunction TSUnionType(node, parent) {\n  return t.isTSArrayType(parent) || t.isTSOptionalType(parent) || t.isTSIntersectionType(parent) || t.isTSUnionType(parent) || t.isTSRestType(parent);\n}\n\nfunction TSInferType(node, parent) {\n  return t.isTSArrayType(parent) || t.isTSOptionalType(parent);\n}\n\nfunction BinaryExpression(node, parent) {\n  return node.operator === \"in\" && (t.isVariableDeclarator(parent) || t.isFor(parent));\n}\n\nfunction SequenceExpression(node, parent) {\n  if (t.isForStatement(parent) || t.isThrowStatement(parent) || t.isReturnStatement(parent) || t.isIfStatement(parent) && parent.test === node || t.isWhileStatement(parent) && parent.test === node || t.isForInStatement(parent) && parent.right === node || t.isSwitchStatement(parent) && parent.discriminant === node || t.isExpressionStatement(parent) && parent.expression === node) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction YieldExpression(node, parent) {\n  return t.isBinary(parent) || t.isUnaryLike(parent) || t.isCallExpression(parent) || t.isOptionalCallExpression(parent) || t.isMemberExpression(parent) || t.isOptionalMemberExpression(parent) || t.isNewExpression(parent) || t.isAwaitExpression(parent) && t.isYieldExpression(node) || t.isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);\n}\n\nfunction ClassExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack, {\n    considerDefaultExports: true\n  });\n}\n\nfunction UnaryLike(node, parent) {\n  return (t.isMemberExpression(parent) || t.isOptionalMemberExpression(parent)) && parent.object === node || (t.isCallExpression(parent) || t.isOptionalCallExpression(parent) || t.isNewExpression(parent)) && parent.callee === node || t.isBinaryExpression(parent, {\n    operator: \"**\",\n    left: node\n  }) || isClassExtendsClause(node, parent);\n}\n\nfunction FunctionExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack, {\n    considerDefaultExports: true\n  });\n}\n\nfunction ArrowFunctionExpression(node, parent) {\n  return t.isExportDeclaration(parent) || ConditionalExpression(node, parent);\n}\n\nfunction ConditionalExpression(node, parent) {\n  if (t.isUnaryLike(parent) || t.isBinary(parent) || t.isConditionalExpression(parent, {\n    test: node\n  }) || t.isAwaitExpression(parent) || t.isOptionalMemberExpression(parent, {\n    object: node\n  }) || t.isOptionalCallExpression(parent, {\n    callee: node\n  }) || t.isTaggedTemplateExpression(parent) || t.isTSTypeAssertion(parent) || t.isTSAsExpression(parent)) {\n    return true;\n  }\n\n  return UnaryLike(node, parent);\n}\n\nfunction OptionalMemberExpression(node, parent) {\n  return t.isCallExpression(parent, {\n    callee: node\n  }) || t.isMemberExpression(parent, {\n    object: node\n  });\n}\n\nfunction OptionalCallExpression(node, parent) {\n  return t.isCallExpression(parent, {\n    callee: node\n  }) || t.isMemberExpression(parent, {\n    object: node\n  });\n}\n\nfunction AssignmentExpression(node, parent, printStack) {\n  if (t.isObjectPattern(node.left)) {\n    return true;\n  } else {\n    return ConditionalExpression(node, parent, printStack);\n  }\n}\n\nfunction LogicalExpression(node, parent) {\n  switch (node.operator) {\n    case \"||\":\n      if (!t.isLogicalExpression(parent)) return false;\n      return parent.operator === \"??\" || parent.operator === \"&&\";\n\n    case \"&&\":\n      return t.isLogicalExpression(parent, {\n        operator: \"??\"\n      });\n\n    case \"??\":\n      return t.isLogicalExpression(parent) && parent.operator !== \"??\";\n  }\n}\n\nfunction isFirstInStatement(printStack, {\n  considerArrow = false,\n  considerDefaultExports = false\n} = {}) {\n  let i = printStack.length - 1;\n  let node = printStack[i];\n  i--;\n  let parent = printStack[i];\n\n  while (i > 0) {\n    if (t.isExpressionStatement(parent, {\n      expression: node\n    }) || t.isTaggedTemplateExpression(parent) || considerDefaultExports && t.isExportDefaultDeclaration(parent, {\n      declaration: node\n    }) || considerArrow && t.isArrowFunctionExpression(parent, {\n      body: node\n    })) {\n      return true;\n    }\n\n    if ((t.isCallExpression(parent) || t.isOptionalCallExpression(parent)) && parent.callee === node || t.isSequenceExpression(parent) && parent.expressions[0] === node || (t.isMemberExpression(parent) || t.isOptionalMemberExpression(parent)) && parent.object === node || t.isConditional(parent, {\n      test: node\n    }) || t.isBinary(parent, {\n      left: node\n    }) || t.isAssignmentExpression(parent, {\n      left: node\n    })) {\n      node = parent;\n      i--;\n      parent = printStack[i];\n    } else {\n      return false;\n    }\n  }\n\n  return false;\n}","map":{"version":3,"sources":["/home/afe/Documents/project/social-ape/social-ape-client/node_modules/@babel/generator/lib/node/parentheses.js"],"names":["Object","defineProperty","exports","value","NullableTypeAnnotation","FunctionTypeAnnotation","UpdateExpression","ObjectExpression","DoExpression","Binary","IntersectionTypeAnnotation","UnionTypeAnnotation","TSAsExpression","TSTypeAssertion","TSIntersectionType","TSUnionType","TSInferType","BinaryExpression","SequenceExpression","AwaitExpression","YieldExpression","ClassExpression","UnaryLike","FunctionExpression","ArrowFunctionExpression","ConditionalExpression","OptionalMemberExpression","OptionalCallExpression","AssignmentExpression","LogicalExpression","t","_interopRequireWildcard","require","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","default","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","PRECEDENCE","in","instanceof","isClassExtendsClause","node","parent","isClassDeclaration","isClassExpression","superClass","isArrayTypeAnnotation","printStack","isUnionTypeAnnotation","isIntersectionTypeAnnotation","isTypeAnnotation","isArrowFunctionExpression","length","isMemberExpression","object","isOptionalMemberExpression","isCallExpression","callee","isOptionalCallExpression","isNewExpression","isFirstInStatement","considerArrow","operator","isBinaryExpression","left","isUnaryLike","isAwaitExpression","isBinary","parentOp","parentPos","nodeOp","nodePos","right","isLogicalExpression","isNullableTypeAnnotation","isTSArrayType","isTSOptionalType","isTSIntersectionType","isTSUnionType","isTSRestType","isVariableDeclarator","isFor","isForStatement","isThrowStatement","isReturnStatement","isIfStatement","test","isWhileStatement","isForInStatement","isSwitchStatement","discriminant","isExpressionStatement","expression","isYieldExpression","isConditionalExpression","considerDefaultExports","isExportDeclaration","isTaggedTemplateExpression","isTSTypeAssertion","isTSAsExpression","isObjectPattern","i","isExportDefaultDeclaration","declaration","body","isSequenceExpression","expressions","isConditional","isAssignmentExpression"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.UpdateExpression = UpdateExpression;\nexports.ObjectExpression = ObjectExpression;\nexports.DoExpression = DoExpression;\nexports.Binary = Binary;\nexports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.TSAsExpression = TSAsExpression;\nexports.TSTypeAssertion = TSTypeAssertion;\nexports.TSIntersectionType = exports.TSUnionType = TSUnionType;\nexports.TSInferType = TSInferType;\nexports.BinaryExpression = BinaryExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.AwaitExpression = exports.YieldExpression = YieldExpression;\nexports.ClassExpression = ClassExpression;\nexports.UnaryLike = UnaryLike;\nexports.FunctionExpression = FunctionExpression;\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.OptionalMemberExpression = OptionalMemberExpression;\nexports.OptionalCallExpression = OptionalCallExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.LogicalExpression = LogicalExpression;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst PRECEDENCE = {\n  \"||\": 0,\n  \"??\": 0,\n  \"&&\": 1,\n  \"|\": 2,\n  \"^\": 3,\n  \"&\": 4,\n  \"==\": 5,\n  \"===\": 5,\n  \"!=\": 5,\n  \"!==\": 5,\n  \"<\": 6,\n  \">\": 6,\n  \"<=\": 6,\n  \">=\": 6,\n  in: 6,\n  instanceof: 6,\n  \">>\": 7,\n  \"<<\": 7,\n  \">>>\": 7,\n  \"+\": 8,\n  \"-\": 8,\n  \"*\": 9,\n  \"/\": 9,\n  \"%\": 9,\n  \"**\": 10\n};\n\nconst isClassExtendsClause = (node, parent) => (t.isClassDeclaration(parent) || t.isClassExpression(parent)) && parent.superClass === node;\n\nfunction NullableTypeAnnotation(node, parent) {\n  return t.isArrayTypeAnnotation(parent);\n}\n\nfunction FunctionTypeAnnotation(node, parent, printStack) {\n  return t.isUnionTypeAnnotation(parent) || t.isIntersectionTypeAnnotation(parent) || t.isArrayTypeAnnotation(parent) || t.isTypeAnnotation(parent) && t.isArrowFunctionExpression(printStack[printStack.length - 3]);\n}\n\nfunction UpdateExpression(node, parent) {\n  return t.isMemberExpression(parent, {\n    object: node\n  }) || t.isOptionalMemberExpression(parent, {\n    object: node\n  }) || t.isCallExpression(parent, {\n    callee: node\n  }) || t.isOptionalCallExpression(parent, {\n    callee: node\n  }) || t.isNewExpression(parent, {\n    callee: node\n  }) || isClassExtendsClause(node, parent);\n}\n\nfunction ObjectExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack, {\n    considerArrow: true\n  });\n}\n\nfunction DoExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack);\n}\n\nfunction Binary(node, parent) {\n  if (node.operator === \"**\" && t.isBinaryExpression(parent, {\n    operator: \"**\"\n  })) {\n    return parent.left === node;\n  }\n\n  if (isClassExtendsClause(node, parent)) {\n    return true;\n  }\n\n  if ((t.isCallExpression(parent) || t.isOptionalCallExpression(parent) || t.isNewExpression(parent)) && parent.callee === node || t.isUnaryLike(parent) || (t.isMemberExpression(parent) || t.isOptionalMemberExpression(parent)) && parent.object === node || t.isAwaitExpression(parent)) {\n    return true;\n  }\n\n  if (t.isBinary(parent)) {\n    const parentOp = parent.operator;\n    const parentPos = PRECEDENCE[parentOp];\n    const nodeOp = node.operator;\n    const nodePos = PRECEDENCE[nodeOp];\n\n    if (parentPos === nodePos && parent.right === node && !t.isLogicalExpression(parent) || parentPos > nodePos) {\n      return true;\n    }\n  }\n}\n\nfunction UnionTypeAnnotation(node, parent) {\n  return t.isArrayTypeAnnotation(parent) || t.isNullableTypeAnnotation(parent) || t.isIntersectionTypeAnnotation(parent) || t.isUnionTypeAnnotation(parent);\n}\n\nfunction TSAsExpression() {\n  return true;\n}\n\nfunction TSTypeAssertion() {\n  return true;\n}\n\nfunction TSUnionType(node, parent) {\n  return t.isTSArrayType(parent) || t.isTSOptionalType(parent) || t.isTSIntersectionType(parent) || t.isTSUnionType(parent) || t.isTSRestType(parent);\n}\n\nfunction TSInferType(node, parent) {\n  return t.isTSArrayType(parent) || t.isTSOptionalType(parent);\n}\n\nfunction BinaryExpression(node, parent) {\n  return node.operator === \"in\" && (t.isVariableDeclarator(parent) || t.isFor(parent));\n}\n\nfunction SequenceExpression(node, parent) {\n  if (t.isForStatement(parent) || t.isThrowStatement(parent) || t.isReturnStatement(parent) || t.isIfStatement(parent) && parent.test === node || t.isWhileStatement(parent) && parent.test === node || t.isForInStatement(parent) && parent.right === node || t.isSwitchStatement(parent) && parent.discriminant === node || t.isExpressionStatement(parent) && parent.expression === node) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction YieldExpression(node, parent) {\n  return t.isBinary(parent) || t.isUnaryLike(parent) || t.isCallExpression(parent) || t.isOptionalCallExpression(parent) || t.isMemberExpression(parent) || t.isOptionalMemberExpression(parent) || t.isNewExpression(parent) || t.isAwaitExpression(parent) && t.isYieldExpression(node) || t.isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);\n}\n\nfunction ClassExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack, {\n    considerDefaultExports: true\n  });\n}\n\nfunction UnaryLike(node, parent) {\n  return (t.isMemberExpression(parent) || t.isOptionalMemberExpression(parent)) && parent.object === node || (t.isCallExpression(parent) || t.isOptionalCallExpression(parent) || t.isNewExpression(parent)) && parent.callee === node || t.isBinaryExpression(parent, {\n    operator: \"**\",\n    left: node\n  }) || isClassExtendsClause(node, parent);\n}\n\nfunction FunctionExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack, {\n    considerDefaultExports: true\n  });\n}\n\nfunction ArrowFunctionExpression(node, parent) {\n  return t.isExportDeclaration(parent) || ConditionalExpression(node, parent);\n}\n\nfunction ConditionalExpression(node, parent) {\n  if (t.isUnaryLike(parent) || t.isBinary(parent) || t.isConditionalExpression(parent, {\n    test: node\n  }) || t.isAwaitExpression(parent) || t.isOptionalMemberExpression(parent, {\n    object: node\n  }) || t.isOptionalCallExpression(parent, {\n    callee: node\n  }) || t.isTaggedTemplateExpression(parent) || t.isTSTypeAssertion(parent) || t.isTSAsExpression(parent)) {\n    return true;\n  }\n\n  return UnaryLike(node, parent);\n}\n\nfunction OptionalMemberExpression(node, parent) {\n  return t.isCallExpression(parent, {\n    callee: node\n  }) || t.isMemberExpression(parent, {\n    object: node\n  });\n}\n\nfunction OptionalCallExpression(node, parent) {\n  return t.isCallExpression(parent, {\n    callee: node\n  }) || t.isMemberExpression(parent, {\n    object: node\n  });\n}\n\nfunction AssignmentExpression(node, parent, printStack) {\n  if (t.isObjectPattern(node.left)) {\n    return true;\n  } else {\n    return ConditionalExpression(node, parent, printStack);\n  }\n}\n\nfunction LogicalExpression(node, parent) {\n  switch (node.operator) {\n    case \"||\":\n      if (!t.isLogicalExpression(parent)) return false;\n      return parent.operator === \"??\" || parent.operator === \"&&\";\n\n    case \"&&\":\n      return t.isLogicalExpression(parent, {\n        operator: \"??\"\n      });\n\n    case \"??\":\n      return t.isLogicalExpression(parent) && parent.operator !== \"??\";\n  }\n}\n\nfunction isFirstInStatement(printStack, {\n  considerArrow = false,\n  considerDefaultExports = false\n} = {}) {\n  let i = printStack.length - 1;\n  let node = printStack[i];\n  i--;\n  let parent = printStack[i];\n\n  while (i > 0) {\n    if (t.isExpressionStatement(parent, {\n      expression: node\n    }) || t.isTaggedTemplateExpression(parent) || considerDefaultExports && t.isExportDefaultDeclaration(parent, {\n      declaration: node\n    }) || considerArrow && t.isArrowFunctionExpression(parent, {\n      body: node\n    })) {\n      return true;\n    }\n\n    if ((t.isCallExpression(parent) || t.isOptionalCallExpression(parent)) && parent.callee === node || t.isSequenceExpression(parent) && parent.expressions[0] === node || (t.isMemberExpression(parent) || t.isOptionalMemberExpression(parent)) && parent.object === node || t.isConditional(parent, {\n      test: node\n    }) || t.isBinary(parent, {\n      left: node\n    }) || t.isAssignmentExpression(parent, {\n      left: node\n    })) {\n      node = parent;\n      i--;\n      parent = printStack[i];\n    } else {\n      return false;\n    }\n  }\n\n  return false;\n}"]},"metadata":{},"sourceType":"script"}